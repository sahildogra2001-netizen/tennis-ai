<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Hawk-Eye Tennis Tracker</title>
    
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/coco-ssd"></script>
    
    <style>
        /* Immersive Black Background */
        body { 
            margin: 0; background: #000; color: white; font-family: 'Courier New', monospace; 
            overflow: hidden; height: 100vh; display: flex; justify-content: center; align-items: center;
        }
        
        /* Heads-Up Display (HUD) */
        .hud {
            position: absolute; top: 10px; left: 10px; z-index: 20;
            background: rgba(0, 0, 0, 0.85); padding: 12px; border-radius: 8px;
            border-left: 5px solid #39ff14; pointer-events: none;
            box-shadow: 0 0 15px rgba(57, 255, 20, 0.2);
            min-width: 130px;
        }
        .stat-row { display: flex; justify-content: space-between; gap: 15px; font-size: 11px; margin-bottom: 5px; }
        .label { color: #aaa; font-weight: bold; } 
        .value { color: #fff; font-weight: bold; }
        
        /* Fullscreen Video & Canvas */
        video, canvas { 
            position: absolute; top: 0; left: 0; width: 100%; height: 100%; 
            object-fit: cover; 
        }
        canvas { z-index: 10; }
        
        /* Loading Screen */
        .loading-screen {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: #111; z-index: 100; display: flex; flex-direction: column;
            justify-content: center; align-items: center; text-align: center;
        }
        .spinner {
            width: 50px; height: 50px; border: 5px solid #333; border-top: 5px solid #39ff14;
            border-radius: 50%; animation: spin 0.8s linear infinite; margin-bottom: 20px;
        }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }

        /* Clear Button */
        .btn-clear {
            position: absolute; bottom: 30px; z-index: 50;
            background: #ff4757; color: white; border: none;
            padding: 15px 30px; border-radius: 30px;
            font-size: 16px; font-weight: bold;
            box-shadow: 0 4px 15px rgba(0,0,0,0.5);
            text-transform: uppercase; letter-spacing: 1px;
            cursor: pointer;
        }
        .btn-clear:active { transform: scale(0.95); background: #e84118; }
    </style>
</head>
<body>

    <div class="hud">
        <div class="stat-row"><span class="label">SYSTEM</span> <span class="value" style="color:#f1c40f">HAWK-EYE</span></div>
        <div class="stat-row"><span class="label">FPS</span> <span class="value" id="fps">0</span></div>
        <div class="stat-row"><span class="label">STATUS</span> <span class="value" id="confidence" style="color:#777">INIT...</span></div>
        <div class="stat-row"><span class="label">SPEED</span> <span class="value" id="speed-val">0 px/f</span></div>
    </div>

    <div class="loading-screen" id="loader">
        <div class="spinner"></div>
        <div style="color:#39ff14; font-size: 1.2em; font-weight:bold; letter-spacing: 1px;">INITIALIZING VISION</div>
        <div style="color:#888; font-size:0.8em; margin-top:10px;">Loading Lite Model (Turbo Mode)...</div>
    </div>

    <video id="video" autoplay playsinline muted></video>
    <canvas id="overlay"></canvas>

    <button class="btn-clear" onclick="clearBounces()">Clear Marks</button>

    <script>
        const video = document.getElementById('video');
        const canvas = document.getElementById('overlay');
        const ctx = canvas.getContext('2d');
        const fpsDisplay = document.getElementById('fps');
        const confDisplay = document.getElementById('confidence');
        const speedDisplay = document.getElementById('speed-val');
        const loader = document.getElementById('loader');

        let model = null;
        let lastTime = 0;
        
        // --- DATA RECORDING ---
        let bounces = [];         // Stores where the ball hit
        let lastVelocityY = 0;    // To detect direction changes
        
        // --- PHYSICS VARIABLES ---
        let trail = [];
        let lastPos = null;       
        let velocity = {x: 0, y: 0}; 
        let speedMagnitude = 0;   
        let lostFrames = 0;       
        let isLocked = false;     
        
        // --- CONSTANTS ---
        const GRAVITY = 0.6;            
        const IMPACT_SPEED_THRESHOLD = 12; // Speed required to "guess" a bounce if lost
        const BOUNCE_COOLDOWN = 15;        // Frames between bounces (prevents double counting)
        const MIN_SPEED_FOR_BOOST = 8;     // Speed boost threshold
        let framesSinceBounce = 0;

        // 1. SETUP CAMERA
        async function setupCamera() {
            try {
                const stream = await navigator.mediaDevices.getUserMedia({
                    video: { 
                        facingMode: 'environment', // Rear Camera
                        width: { ideal: 640 },     // Low Res = High Speed
                        height: { ideal: 480 } 
                    },
                    audio: false
                });
                video.srcObject = stream;
                return new Promise(resolve => {
                    video.onloadedmetadata = () => {
                        canvas.width = video.videoWidth;
                        canvas.height = video.videoHeight;
                        resolve(video);
                    };
                });
            } catch (e) { alert("Camera Access Error. Ensure HTTPS is enabled."); }
        }

        // 2. LOAD AI
        async function loadModel() {
            model = await cocoSsd.load({ base: 'lite_mobilenet_v2' });
            loader.style.display = 'none';
            detectFrame();
        }

        // 3. MAIN LOOP
        async function detectFrame(time) {
            if (!model) return;
            if (lastTime) fpsDisplay.innerText = Math.round(1000 / (time - lastTime));
            lastTime = time;

            const predictions = await model.detect(video);
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Draw the Bounce History first (Bottom Layer)
            drawImpactMap();

            let bestPrediction = null;
            let highestScore = 0;

            predictions.forEach(prediction => {
                if (prediction.class === 'sports ball') {
                    let adjustedScore = prediction.score;
                    
                    // SPEED BOOST: If fast, increase confidence
                    if (isLocked && speedMagnitude > MIN_SPEED_FOR_BOOST) {
                        adjustedScore += 0.4;
                        if (adjustedScore > 1.0) adjustedScore = 1.0;
                    }

                    // STICKY THRESHOLD: Lower requirement if already locked
                    const threshold = isLocked ? 0.15 : 0.35;

                    if (adjustedScore > threshold) {
                        if (adjustedScore > highestScore) {
                            highestScore = adjustedScore;
                            bestPrediction = prediction;
                        }
                    }
                }
            });

            if (bestPrediction) {
                // === BALL FOUND ===
                isLocked = true;
                lostFrames = 0;
                framesSinceBounce++;

                const [x, y, width, height] = bestPrediction.bbox;
                const centerX = x + width / 2;
                const centerY = y + height / 2;

                if (lastPos) {
                    const rawVx = centerX - lastPos.x;
                    const rawVy = centerY - lastPos.y;
                    
                    velocity.x = (velocity.x * 0.5) + (rawVx * 0.5);
                    velocity.y = (velocity.y * 0.5) + (rawVy * 0.5);
                    speedMagnitude = Math.sqrt(velocity.x**2 + velocity.y**2);
                    speedDisplay.innerText = Math.round(speedMagnitude) + " px/f";
                    
                    // --- VISIBLE BOUNCE DETECTION ---
                    // If ball was falling (>5) and now stops or goes up (<-2)
                    if (framesSinceBounce > BOUNCE_COOLDOWN) {
                        if (lastVelocityY > 5 && velocity.y < -2) {
                             registerBounce(centerX, centerY + height/2); // Mark bottom of ball
                        }
                    }
                    lastVelocityY = velocity.y;
                }
                lastPos = { x: centerX, y: centerY };

                confDisplay.innerText = "LOCKED";
                confDisplay.style.color = "#39ff14";
                updateTrail(centerX, centerY);
                drawTracker(centerX, centerY, width, height, false);

            } else {
                // === BALL LOST (PREDICTION) ===
                if (isLocked && lostFrames < MAX_COAST) {
                    
                    // --- GHOST BOUNCE DETECTION ---
                    // If lost while falling fast, assume impact
                    if (lostFrames === 0 && velocity.y > IMPACT_SPEED_THRESHOLD) {
                        if (framesSinceBounce > BOUNCE_COOLDOWN) {
                            registerBounce(lastPos.x, lastPos.y + 20); 
                            velocity.y = -velocity.y * 0.65; // Bounce Ghost Up
                            console.log("Ghost Bounce Detected");
                        }
                    }

                    lostFrames++;
                    framesSinceBounce++;
                    
                    velocity.y += GRAVITY;          
                    lastPos.x += velocity.x;        
                    lastPos.y += velocity.y;        

                    confDisplay.innerText = "PREDICTING";
                    confDisplay.style.color = "orange";
                    updateTrail(lastPos.x, lastPos.y);
                    drawTracker(lastPos.x, lastPos.y, 40, 40, true);
                } else {
                    isLocked = false;
                    speedMagnitude = 0;
                    confDisplay.innerText = "SCANNING";
                    confDisplay.style.color = "#777";
                    speedDisplay.innerText = "0 px/f";
                    if (trail.length > 0) trail.shift();
                }
            }
            
            drawTrail();
            requestAnimationFrame(detectFrame);
        }

        // --- IMPACT SYSTEM ---
        function registerBounce(x, y) {
            bounces.push({x: x, y: y});
            framesSinceBounce = 0; 
            if (navigator.vibrate) navigator.vibrate(50); // Haptic Feedback
        }

        function drawImpactMap() {
            bounces.forEach(bounce => {
                // Draw Yellow 'X'
                ctx.beginPath();
                ctx.strokeStyle = "#FFFF00";
                ctx.lineWidth = 4;
                const size = 15;
                ctx.moveTo(bounce.x - size, bounce.y - size);
                ctx.lineTo(bounce.x + size, bounce.y + size);
                ctx.moveTo(bounce.x + size, bounce.y - size);
                ctx.lineTo(bounce.x - size, bounce.y + size);
                ctx.stroke();
                
                // Draw Ripple
                ctx.beginPath();
                ctx.strokeStyle = "rgba(255, 255, 0, 0.4)";
                ctx.lineWidth = 2;
                ctx.arc(bounce.x, bounce.y, 25, 0, Math.PI*2);
                ctx.stroke();
            });
        }
        
        function clearBounces() { bounces = []; }

        // --- DRAWING TOOLS ---
        function updateTrail(x, y) {
            trail.push({x, y});
            if (trail.length > 15) trail.shift();
        }

        function drawTracker(x, y, w, h, isGhost) {
            ctx.save();
            ctx.translate(x, y);
            ctx.strokeStyle = isGhost ? '#f39c12' : '#39ff14';
            ctx.lineWidth = (!isGhost && speedMagnitude > MIN_SPEED_FOR_BOOST) ? 5 : 3;
            if (isGhost) ctx.setLineDash([5, 5]); 
            const boxSize = isGhost ? 30 : Math.max(w, h); 
            ctx.strokeRect(-boxSize/2, -boxSize/2, boxSize, boxSize);
            ctx.restore();
        }

        function drawTrail() {
            if (trail.length < 2) return;
            ctx.beginPath();
            const gradient = ctx.createLinearGradient(trail[0].x, trail[0].y, trail[trail.length-1].x, trail[trail.length-1].y);
            gradient.addColorStop(0, "rgba(57, 255, 20, 0)");
            gradient.addColorStop(1, "rgba(57, 255, 20, 0.6)");
            ctx.strokeStyle = gradient;
            ctx.lineWidth = 5;
            ctx.lineCap = "round";
            ctx.moveTo(trail[0].x, trail[0].y);
            for (let i = 1; i < trail.length; i++) { ctx.lineTo(trail[i].x, trail[i].y); }
            ctx.stroke();
        }

        setupCamera().then(loadModel);
    </script>
</body>
</html>
