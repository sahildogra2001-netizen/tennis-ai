<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Pro-Court Tennis Tracker (Final)</title>
    
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/coco-ssd"></script>
    
    <style>
        /* Immersive Black Background */
        body { 
            margin: 0; background: #000; color: white; font-family: 'Courier New', monospace; 
            overflow: hidden; height: 100vh; display: flex; justify-content: center; align-items: center;
        }
        
        /* Heads-Up Display (HUD) */
        .hud {
            position: absolute; top: 10px; left: 10px; z-index: 20;
            background: rgba(0, 0, 0, 0.85); padding: 12px; border-radius: 8px;
            border-left: 5px solid #39ff14; pointer-events: none;
            box-shadow: 0 0 15px rgba(57, 255, 20, 0.2);
            min-width: 140px;
        }
        .stat-row { display: flex; justify-content: space-between; gap: 15px; font-size: 11px; margin-bottom: 5px; }
        .label { color: #aaa; font-weight: bold; } 
        .value { color: #fff; font-weight: bold; }
        
        /* Fullscreen Video & Canvas Overlay */
        video, canvas { 
            position: absolute; top: 0; left: 0; width: 100%; height: 100%; 
            object-fit: cover; 
        }
        canvas { z-index: 10; }
        
        /* Loading Screen Styling */
        .loading-screen {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: #111; z-index: 100; display: flex; flex-direction: column;
            justify-content: center; align-items: center; text-align: center;
        }
        .spinner {
            width: 50px; height: 50px; border: 5px solid #333; border-top: 5px solid #39ff14;
            border-radius: 50%; animation: spin 0.8s linear infinite; margin-bottom: 20px;
        }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
    </style>
</head>
<body>

    <div class="hud">
        <div class="stat-row"><span class="label">ENGINE</span> <span class="value" style="color:#f1c40f">TURBO V4</span></div>
        <div class="stat-row"><span class="label">FPS</span> <span class="value" id="fps">0</span></div>
        <div class="stat-row"><span class="label">STATUS</span> <span class="value" id="confidence" style="color:#777">INIT...</span></div>
        <div class="stat-row"><span class="label">SPEED</span> <span class="value" id="speed-val">0 px/f</span></div>
    </div>

    <div class="loading-screen" id="loader">
        <div class="spinner"></div>
        <div style="color:#39ff14; font-size: 1.2em; font-weight:bold; letter-spacing: 1px;">INITIALIZING VISION</div>
        <div style="color:#888; font-size:0.8em; margin-top:10px;">Loading Neural Network (Lite Model)...</div>
    </div>

    <video id="video" autoplay playsinline muted></video>
    <canvas id="overlay"></canvas>

    <script>
        const video = document.getElementById('video');
        const canvas = document.getElementById('overlay');
        const ctx = canvas.getContext('2d');
        const fpsDisplay = document.getElementById('fps');
        const confDisplay = document.getElementById('confidence');
        const speedDisplay = document.getElementById('speed-val');
        const loader = document.getElementById('loader');

        let model = null;
        let lastTime = 0;
        
        // --- PHYSICS ENGINE VARIABLES ---
        let trail = [];
        let lastPos = null;       
        let velocity = {x: 0, y: 0}; 
        let speedMagnitude = 0;   // Current speed of the ball
        let lostFrames = 0;       
        let isLocked = false;     
        
        // --- TUNING CONSTANTS ---
        const MAX_COAST = 25;           // How long to predict if lost (frames)
        const GRAVITY = 0.6;            // Gravity force
        const IMPACT_SPEED_THRESHOLD = 12; // If falling faster than this, assume bounce
        const MIN_SPEED_FOR_BOOST = 8;  // Speed required to trigger confidence boost

        // 1. SETUP CAMERA (Rear-Facing, Optimized for High FPS)
        async function setupCamera() {
            try {
                const stream = await navigator.mediaDevices.getUserMedia({
                    video: { 
                        facingMode: 'environment', // Rear Camera
                        width: { ideal: 640 },     // Lower res = Higher Speed on Mobile
                        height: { ideal: 480 } 
                    },
                    audio: false
                });
                video.srcObject = stream;
                return new Promise(resolve => {
                    video.onloadedmetadata = () => {
                        canvas.width = video.videoWidth;
                        canvas.height = video.videoHeight;
                        resolve(video);
                    };
                });
            } catch (e) { 
                alert("Camera Error: Please ensure you are on HTTPS and allowed camera access."); 
            }
        }

        // 2. LOAD AI MODEL (Lite Version)
        async function loadModel() {
            // "lite_mobilenet_v2" is critical for mobile performance
            model = await cocoSsd.load({ base: 'lite_mobilenet_v2' });
            loader.style.display = 'none'; // Hide loading screen
            detectFrame(); // Start Loop
        }

        // 3. MAIN GAME LOOP
        async function detectFrame(time) {
            if (!model) return;

            // Calculate FPS
            if (lastTime) {
                const fps = Math.round(1000 / (time - lastTime));
                fpsDisplay.innerText = fps;
                fpsDisplay.style.color = fps > 25 ? "#39ff14" : (fps > 15 ? "orange" : "red");
            }
            lastTime = time;

            // Run Detection
            const predictions = await model.detect(video);
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            let bestPrediction = null;
            let highestScore = 0;

            predictions.forEach(prediction => {
                // Only track "sports ball"
                if (prediction.class === 'sports ball') {
                    
                    // --- SPEED BOOST LOGIC ---
                    let adjustedScore = prediction.score;
                    
                    // If we are locked and moving fast, boost confidence
                    if (isLocked && speedMagnitude > MIN_SPEED_FOR_BOOST) {
                        adjustedScore += 0.45; // Huge boost for fast moving objects
                        if (adjustedScore > 1.0) adjustedScore = 1.0;
                    }

                    // --- STICKY THRESHOLD ---
                    // If locked: Accept anything > 15% (0.15)
                    // If searching: Require > 35% (0.35)
                    const threshold = isLocked ? 0.15 : 0.35;

                    if (adjustedScore > threshold) {
                        if (adjustedScore > highestScore) {
                            highestScore = adjustedScore;
                            bestPrediction = prediction;
                        }
                    }
                }
            });

            if (bestPrediction) {
                // === BALL FOUND ===
                isLocked = true;
                lostFrames = 0;

                const [x, y, width, height] = bestPrediction.bbox;
                const centerX = x + width / 2;
                const centerY = y + height / 2;

                // Update Physics (Velocity Calculation)
                if (lastPos) {
                    const rawVx = centerX - lastPos.x;
                    const rawVy = centerY - lastPos.y;
                    
                    // Smoothing: 50% old speed, 50% new speed
                    velocity.x = (velocity.x * 0.5) + (rawVx * 0.5);
                    velocity.y = (velocity.y * 0.5) + (rawVy * 0.5);
                    
                    // Update Speed Display
                    speedMagnitude = Math.sqrt(velocity.x**2 + velocity.y**2);
                    speedDisplay.innerText = Math.round(speedMagnitude) + " px/f";
                }
                lastPos = { x: centerX, y: centerY };

                // HUD Update
                confDisplay.innerText = "LOCKED (" + Math.round(highestScore * 100) + "%)";
                confDisplay.style.color = "#39ff14"; // Neon Green
                
                updateTrail(centerX, centerY);
                drawTracker(centerX, centerY, width, height, false);

            } else {
                // === BALL LOST (PHYSICS PREDICTION) ===
                if (isLocked && lostFrames < MAX_COAST) {
                    
                    // --- AUTO-BOUNCE LOGIC ---
                    // If we just lost it, and it was falling FAST... assume it hit the floor.
                    if (lostFrames === 0 && velocity.y > IMPACT_SPEED_THRESHOLD) {
                        velocity.y = -velocity.y * 0.65; // Bounce UP with 65% energy
                        console.log("Bounce Detected! Reversing Velocity.");
                    }

                    lostFrames++;
                    
                    // Apply Physics
                    velocity.y += GRAVITY;          // Gravity pulls down
                    lastPos.x += velocity.x;        // Move X
                    lastPos.y += velocity.y;        // Move Y
                    velocity.x *= 0.98;             // Air Resistance (Drag)

                    confDisplay.innerText = "PREDICTING (" + lostFrames + ")";
                    confDisplay.style.color = "#f39c12"; // Orange

                    updateTrail(lastPos.x, lastPos.y);
                    drawTracker(lastPos.x, lastPos.y, 40, 40, true); // True = Ghost Mode
                } else {
                    // Lock Lost
                    isLocked = false;
                    speedMagnitude = 0;
                    confDisplay.innerText = "SCANNING...";
                    confDisplay.style.color = "#777";
                    speedDisplay.innerText = "0 px/f";
                    if (trail.length > 0) trail.shift();
                }
            }
            
            drawTrail();
            requestAnimationFrame(detectFrame);
        }

        // --- DRAWING FUNCTIONS ---

        function updateTrail(x, y) {
            trail.push({x, y});
            if (trail.length > 20) trail.shift(); // Trail Length
        }

        function drawTracker(x, y, w, h, isGhost) {
            ctx.save();
            ctx.translate(x, y);
            
            // Style: Green for Real, Orange for Ghost/Prediction
            ctx.strokeStyle = isGhost ? '#f39c12' : '#39ff14';
            
            // If moving fast, make the box thicker
            ctx.lineWidth = (!isGhost && speedMagnitude > MIN_SPEED_FOR_BOOST) ? 5 : 3;
            
            if (isGhost) ctx.setLineDash([6, 6]); // Dashed line for ghost

            // Draw Dynamic Box
            // Ghost box is fixed size (30px), Real box matches ball size
            const boxSize = isGhost ? 30 : Math.max(w, h); 
            ctx.strokeRect(-boxSize/2, -boxSize/2, boxSize, boxSize);
            
            // Draw Crosshair
            ctx.beginPath();
            ctx.moveTo(0, -10); ctx.lineTo(0, 10);
            ctx.moveTo(-10, 0); ctx.lineTo(10, 0);
            ctx.lineWidth = 2;
            ctx.stroke();
            
            ctx.restore();
        }

        function drawTrail() {
            if (trail.length < 2) return;
            ctx.beginPath();
            // Gradient: Transparent to Neon Green
            const gradient = ctx.createLinearGradient(
                trail[0].x, trail[0].y, 
                trail[trail.length-1].x, trail[trail.length-1].y
            );
            gradient.addColorStop(0, "rgba(57, 255, 20, 0)");
            gradient.addColorStop(1, "rgba(57, 255, 20, 0.6)");
            
            ctx.strokeStyle = gradient;
            ctx.lineWidth = 6;
            ctx.lineCap = "round";
            
            ctx.moveTo(trail[0].x, trail[0].y);
            for (let i = 1; i < trail.length; i++) {
                ctx.lineTo(trail[i].x, trail[i].y);
            }
            ctx.stroke();
        }

        // Start the System
        setupCamera().then(loadModel);
    </script>
</body>
</html>
