<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<title>Hawk-Eye Mobile Tracker</title>
<style>
body { margin:0; background:black; overflow:hidden; font-family:sans-serif; }
video, canvas { position:absolute; inset:0; margin:auto; }
canvas { z-index:10; }
</style>
</head>
<body>

<video id="video" autoplay playsinline muted></video>
<canvas id="canvas"></canvas>

<script>
/* ==========================
   MODE SELECTION
========================== */
// ðŸ” change to "indoor" or "outdoor"
const COURT_MODE = "outdoor";

/* ==========================
   MODE TUNING
========================== */
const MODES = {
  indoor: {
    BG_LEARN_RATE: 0.08,
    MOTION_THRESHOLD: 14,
    SAT_MIN: 0.35,
    VAL_MIN: 0.35
  },
  outdoor: {
    BG_LEARN_RATE: 0.03,
    MOTION_THRESHOLD: 20,
    SAT_MIN: 0.45,
    VAL_MIN: 0.45
  }
};

const MODE = MODES[COURT_MODE];

/* ==========================
   DOM
========================== */
const video = document.getElementById("video");
const canvas = document.getElementById("canvas");
const ctx = canvas.getContext("2d");

/* ==========================
   PROCESSING CANVAS (LOW RES)
========================== */
const procCanvas = document.createElement("canvas");
const procCtx = procCanvas.getContext("2d", { willReadFrequently:true });

const PROC_WIDTH = 160;
let PROC_HEIGHT = 0;

/* ==========================
   BACKGROUND MODEL
========================== */
let background = null;
let motionMask = null;

/* ==========================
   STATE
========================== */
let lastPos = null;
let lastVelY = 0;
let lastBounce = 0;

/* ==========================
   CAMERA
========================== */
async function setupCamera() {
  const stream = await navigator.mediaDevices.getUserMedia({
    video:{ facingMode:"environment" }, audio:false
  });
  video.srcObject = stream;

  video.onloadedmetadata = () => {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;

    PROC_HEIGHT = Math.round(PROC_WIDTH * video.videoHeight / video.videoWidth);
    procCanvas.width = PROC_WIDTH;
    procCanvas.height = PROC_HEIGHT;

    requestAnimationFrame(loop);
  };
}

/* ==========================
   MAIN LOOP
========================== */
function loop() {
  ctx.drawImage(video,0,0,canvas.width,canvas.height);

  let mask = detectMotion();
  mask = cleanMotion(mask);
  const ball = findBall(mask);

  if (ball) {
    ctx.strokeStyle="#39ff14";
    ctx.lineWidth=3;
    ctx.beginPath();
    ctx.arc(ball.x, ball.y, 18, 0, Math.PI*2);
    ctx.stroke();

    if (lastPos) {
      const vy = ball.y - lastPos.y;

      if (
        lastVelY > 8 &&
        vy < -8 &&
        Date.now() - lastBounce > 600 &&
        ball.y > canvas.height * 0.55
      ) {
        lastBounce = Date.now();
        if (navigator.vibrate) navigator.vibrate(80);
      }

      lastVelY = vy;
    }
    lastPos = ball;
  } else {
    lastPos = null;
  }

  requestAnimationFrame(loop);
}

/* ==========================
   MOTION DETECTION
========================== */
function detectMotion() {
  procCtx.drawImage(video,0,0,PROC_WIDTH,PROC_HEIGHT);
  const frame = procCtx.getImageData(0,0,PROC_WIDTH,PROC_HEIGHT);
  const d = frame.data;

  if (!background) {
    background = new Float32Array(d.length);
    for (let i=0;i<d.length;i++) background[i]=d[i];
    motionMask = new Uint8ClampedArray(PROC_WIDTH*PROC_HEIGHT);
    return motionMask;
  }

  motionMask.fill(0);

  for (let i=0;i<d.length;i+=4) {
    const dr = Math.abs(d[i]-background[i]);
    const dg = Math.abs(d[i+1]-background[i+1]);
    const db = Math.abs(d[i+2]-background[i+2]);
    const diff = dr+dg+db;

    if (diff > MODE.MOTION_THRESHOLD*3) {
      motionMask[i>>2]=255;
    } else {
      background[i]+= (d[i]-background[i])*MODE.BG_LEARN_RATE;
      background[i+1]+= (d[i+1]-background[i+1])*MODE.BG_LEARN_RATE;
      background[i+2]+= (d[i+2]-background[i+2])*MODE.BG_LEARN_RATE;
    }
  }
  return motionMask;
}

/* ==========================
   MORPHOLOGY
========================== */
function cleanMotion(mask) {
  const out = new Uint8ClampedArray(mask.length);
  for (let y=1;y<PROC_HEIGHT-1;y++) {
    for (let x=1;x<PROC_WIDTH-1;x++) {
      let i=y*PROC_WIDTH+x,count=0;
      for(let dy=-1;dy<=1;dy++)
        for(let dx=-1;dx<=1;dx++)
          if(mask[i+dy*PROC_WIDTH+dx]) count++;
      if(count>=4) out[i]=255;
    }
  }
  return out;
}

/* ==========================
   BALL DETECTION + COLOR CHECK
========================== */
function findBall(mask) {
  const visited = new Uint8ClampedArray(mask.length);
  let best=null;

  for(let i=0;i<mask.length;i++){
    if(mask[i] && !visited[i]){
      const b=flood(mask,visited,i%PROC_WIDTH,(i/PROC_WIDTH)|0);
      if(b.size<14||b.size>500) continue;
      if(!isTennisColor(b.cx,b.cy)) continue;
      if(!best||b.size>best.size) best=b;
    }
  }
  if(!best) return null;

  return {
    x: best.cx * canvas.width / PROC_WIDTH,
    y: best.cy * canvas.height / PROC_HEIGHT
  };
}

function flood(mask,visited,sx,sy){
  const st=[[sx,sy]];
  let sxm=0,sym=0,c=0;
  while(st.length){
    const [x,y]=st.pop(),i=y*PROC_WIDTH+x;
    if(x<0||y<0||x>=PROC_WIDTH||y>=PROC_HEIGHT) continue;
    if(visited[i]||!mask[i]) continue;
    visited[i]=1;
    sxm+=x; sym+=y; c++;
    st.push([x+1,y],[x-1,y],[x,y+1],[x,y-1]);
  }
  return { cx:sxm/c, cy:sym/c, size:c };
}

/* ==========================
   COLOR VERIFICATION (HSV-ish)
========================== */
function isTennisColor(px,py){
  const x=Math.floor(px),y=Math.floor(py);
  const d=procCtx.getImageData(x,y,1,1).data;
  const r=d[0]/255,g=d[1]/255,b=d[2]/255;
  const max=Math.max(r,g,b),min=Math.min(r,g,b);
  const v=max;
  const s=max===0?0:(max-min)/max;

  // tennis yellow-green window
  return (
    g>r*1.1 &&
    g>b*1.1 &&
    s>MODE.SAT_MIN &&
    v>MODE.VAL_MIN
  );
}

/* ==========================
   START
========================== */
setupCamera();
</script>

</body>
</html>
