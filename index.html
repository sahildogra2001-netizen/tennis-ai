<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Hawk-Eye: Anti-Grass Edition</title>
    <style>
        /* Immersive Black Background */
        body { 
            margin: 0; background: #000; overflow: hidden; height: 100vh; 
            display: flex; align-items: center; justify-content: center; 
            font-family: 'Courier New', monospace; 
        }
        
        /* Video & Drawing Canvas */
        video, canvas { 
            position: absolute; top: 0; left: 0; width: 100%; height: 100%; 
            object-fit: cover; 
        }
        canvas { z-index: 10; pointer-events: none; }
        
        /* Heads-Up Display */
        .hud {
            position: absolute; top: 10px; left: 10px; z-index: 20;
            background: rgba(0,0,0,0.85); padding: 12px; border-radius: 8px;
            border-left: 5px solid #ff4757; pointer-events: none;
            box-shadow: 0 0 15px rgba(255, 71, 87, 0.2);
            min-width: 160px;
        }
        .stat-row { color: #fff; font-size: 12px; margin-bottom: 5px; }
        .label { color: #aaa; font-weight: bold; margin-right: 10px; }
        .val { color: #fff; font-weight: bold; }
        
        /* Control Buttons */
        .controls {
            position: absolute; bottom: 30px; z-index: 100; /* High Z-Index to ensure clickable */
            width: 100%; display: flex; justify-content: center; gap: 15px;
        }
        .btn {
            background: #333; color: white; border: 1px solid #555;
            padding: 15px 30px; border-radius: 30px; font-weight: bold; 
            cursor: pointer; text-transform: uppercase; font-size: 16px;
            box-shadow: 0 4px 10px rgba(0,0,0,0.5); user-select: none;
        }
        .btn:active { transform: scale(0.95); background: #555; }
        .btn-clear { background: #ff4757; border-color: #ff4757; }
        .btn-mask { background: #2f3542; color: #39ff14; border-color: #39ff14; }
    </style>
</head>
<body>

    <div class="hud">
        <div class="stat-row" style="color:#ff4757; font-size:14px; margin-bottom:8px;">ANTI-GRASS MODE</div>
        <div class="stat-row"><span class="label">STATUS</span> <span class="val" id="status">SCANNING</span></div>
        <div class="stat-row"><span class="label">RED/GRN RATIO</span> <span class="val" id="ratio-val">0.0</span></div>
        <div class="stat-row"><span class="label">DETECTED</span> <span class="val" id="pixels">0 px</span></div>
    </div>

    <video id="video" autoplay playsinline muted></video>
    <canvas id="overlay"></canvas>

    <div class="controls">
        <button class="btn btn-mask" onclick="toggleMask()">üëÅ Mask</button>
        <button class="btn btn-clear" onclick="clearMap()">‚úñ Clear Marks</button>
    </div>

    <script>
        const video = document.getElementById('video');
        const canvas = document.getElementById('overlay');
        const ctx = canvas.getContext('2d');
        const pxDisplay = document.getElementById('pixels');
        const statusDisplay = document.getElementById('status');
        const ratioDisplay = document.getElementById('ratio-val');
        
        // --- STATE VARIABLES ---
        let bounces = [];
        let trail = [];
        let lastPos = null;
        let framesConsistent = 0; 
        let showMask = false;
        
        // --- MOTION GATE STATE ---
        let startPos = null;      
        let stationaryFrames = 0; 
        
        // --- TUNING CONSTANTS ---
        
        // 1. COLOR FILTER (The Anti-Grass Logic)
        const COLOR_MIN = { h: 35, s: 50, l: 35 }; 
        const COLOR_MAX = { h: 90, s: 100, l: 100 };
        
        // 2. STABILITY (Increased to stop flickering)
        const MIN_BLOB_SIZE = 40; 
        const CONSISTENCY_REQUIRED = 5; // Needs 5 frames to lock (slower but safer)

        // 3. MOTION GATE
        const STATIONARY_LIMIT = 30; 
        const MOVEMENT_REQUIRED = 20;

        // --- SETUP CAMERA ---
        async function setupCamera() {
            try {
                const stream = await navigator.mediaDevices.getUserMedia({
                    video: { facingMode: 'environment', width: { ideal: 640 }, height: { ideal: 480 } },
                    audio: false
                });
                video.srcObject = stream;
                video.onloadedmetadata = () => {
                    canvas.width = video.videoWidth;
                    canvas.height = video.videoHeight;
                    requestAnimationFrame(processFrame);
                };
            } catch (e) { alert("Camera Error. Use HTTPS."); }
        }

        // --- MAIN LOOP ---
        function processFrame() {
            ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
            const frame = ctx.getImageData(0, 0, canvas.width, canvas.height);
            const data = frame.data;
            const width = canvas.width;
            
            let sumX = 0, sumY = 0, count = 0;
            let avgRatio = 0;

            // PIXEL SCAN (Every 16th byte)
            for (let i = 0; i < data.length; i += 16) { 
                const r = data[i], g = data[i+1], b = data[i+2];
                const hsl = rgbToHsl(r, g, b);

                // 1. IS IT NEON?
                const isNeon = (
                    hsl.h >= COLOR_MIN.h && hsl.h <= COLOR_MAX.h &&
                    hsl.s >= COLOR_MIN.s && hsl.s <= COLOR_MAX.s &&
                    hsl.l >= COLOR_MIN.l && hsl.l <= COLOR_MAX.l
                );

                // 2. IS IT GRASS? (The new fix)
                // Grass is pure green (High G, Low R).
                // Tennis ball is Yellow (High G, High R).
                // We enforce that Red must be at least 50% of Green.
                const isNotGrass = (r > g * 0.5); 
                
                // 3. IS IT BRIGHT ENOUGH? (Reject shadows)
                const isBright = (r + g + b) > 150;

                if (isNeon && isNotGrass && isBright) {
                    sumX += (i / 4) % width;
                    sumY += Math.floor((i / 4) / width);
                    count++;
                    avgRatio += (r / (g+1)); // Track ratio for debugging
                    
                    if (showMask) { // White pixels for detected ball
                        data[i] = 255; data[i+1] = 255; data[i+2] = 255; 
                    }
                } else if (showMask) { // Black pixels for ignored background
                    data[i] = 0; data[i+1] = 0; data[i+2] = 0; 
                }
            }

            if (showMask) ctx.putImageData(frame, 0, 0);
            else ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            drawBounces(); 

            // Debug Stats
            pxDisplay.innerText = count + (framesConsistent > CONSISTENCY_REQUIRED ? " (LOCKED)" : "");
            if(count > 0) ratioDisplay.innerText = (avgRatio / count).toFixed(2);

            // --- TRACKING ---
            if (count > MIN_BLOB_SIZE) {
                const centerX = sumX / count;
                const centerY = sumY / count;
                const radius = Math.sqrt(count);

                // Teleport Check
                let dist = 0;
                if (lastPos) dist = Math.sqrt((centerX-lastPos.x)**2 + (centerY-lastPos.y)**2);

                if (!lastPos || dist < 150) { 
                    framesConsistent++;
                } else {
                    framesConsistent = 0; 
                }

                // MOTION GATE
                if (framesConsistent > 5) {
                    if (!startPos) startPos = {x: centerX, y: centerY};
                    const travelDist = Math.sqrt((centerX-startPos.x)**2 + (centerY-startPos.y)**2);
                    
                    if (travelDist < MOVEMENT_REQUIRED) stationaryFrames++;
                    else { stationaryFrames = 0; startPos = {x: centerX, y: centerY}; }
                }

                if (stationaryFrames > STATIONARY_LIMIT) {
                    statusDisplay.innerText = "IGNORED (STATIC)";
                    statusDisplay.style.color = "red";
                    framesConsistent = 0; 
                    lastPos = null;
                } else if (framesConsistent > CONSISTENCY_REQUIRED) {
                    statusDisplay.innerText = "TRACKING BALL";
                    statusDisplay.style.color = "#39ff14";
                    
                    updateTrail(centerX, centerY);
                    
                    // Bounce Physics
                    if (lastPos && lastPos.valid) {
                        const dy = centerY - lastPos.y;
                        if (dy < -3 && lastPos.dy > 5) registerBounce(centerX, centerY + 10);
                        lastPos.dy = dy;
                    }
                    
                    drawTracker(centerX, centerY, radius);
                    lastPos = { x: centerX, y: centerY, dy: (lastPos ? lastPos.dy : 0), valid: true };
                }
            } else {
                framesConsistent = 0;
                stationaryFrames = 0;
                lastPos = null;
                statusDisplay.innerText = "SCANNING...";
                statusDisplay.style.color = "#777";
            }

            drawTrail();
            requestAnimationFrame(processFrame);
        }

        // --- DRAWING ---
        function drawTracker(x, y, r) {
            ctx.beginPath(); ctx.arc(x, y, r, 0, Math.PI*2);
            ctx.strokeStyle = "#39ff14"; ctx.lineWidth = 4; ctx.stroke();
            ctx.beginPath(); ctx.moveTo(x-10, y); ctx.lineTo(x+10, y); 
            ctx.moveTo(x, y-10); ctx.lineTo(x, y+10); ctx.lineWidth=2; ctx.stroke();
        }

        function drawTrail() {
            if (trail.length < 2) return;
            ctx.beginPath(); ctx.strokeStyle = "rgba(57,255,20,0.6)"; ctx.lineWidth = 4;
            ctx.moveTo(trail[0].x, trail[0].y);
            for(let p of trail) ctx.lineTo(p.x, p.y);
            ctx.stroke();
        }

        function drawBounces() {
            for(let b of bounces) {
                ctx.beginPath(); ctx.strokeStyle = "yellow"; ctx.lineWidth=3;
                ctx.moveTo(b.x-10, b.y-10); ctx.lineTo(b.x+10, b.y+10);
                ctx.moveTo(b.x+10, b.y-10); ctx.lineTo(b.x-10, b.y+10);
                ctx.stroke();
            }
        }
        
        function updateTrail(x, y) {
            trail.push({x,y}); if(trail.length > 10) trail.shift();
        }

        function registerBounce(x, y) {
            bounces.push({x,y});
            if(navigator.vibrate) navigator.vibrate(50);
        }
        
        // --- BUTTON FUNCTIONS ---
        function clearMap() { 
            bounces = []; 
            console.log("Marks cleared"); // Debug check
        }
        
        function toggleMask() { 
            showMask = !showMask; 
        }

        // --- COLOR UTILS ---
        function rgbToHsl(r, g, b) {
            r/=255, g/=255, b/=255;
            const max = Math.max(r, g, b), min = Math.min(r, g, b);
            let h, s, l = (max + min) / 2;
            if (max == min) { h = s = 0; } 
            else {
                const d = max - min;
                s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
                switch (max) {
                    case r: h = (g - b) / d + (g < b ? 6 : 0); break;
                    case g: h = (b - r) / d + 2; break;
                    case b: h = (r - g) / d + 4; break;
                }
                h *= 60;
            }
            return { h, s: s * 100, l: l * 100 };
        }

        setupCamera();
    </script>
</body>
</html>
